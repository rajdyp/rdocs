---
title: "Core Concepts Quiz"
linkTitle: Core Concepts
type: docs
weight: 1
prev: /quiz/linux
---

{{< quiz id="linux-core-concepts-quiz" >}}
{
  "questions": [
    {
      "id": "linux-core-concepts-quiz-01",
      "type": "mcq",
      "question": "In the Linux architecture, what acts as the controlled gateway between user space and kernel space?",
      "options": [
        "Shell",
        "System Call Interface",
        "System Libraries (glibc)",
        "Device Drivers"
      ],
      "answer": 1,
      "explanation": "The System Call Interface is the controlled gateway between user and kernel space. It acts as the security boundary where CPU mode switches occur (user mode to kernel mode and back).",
      "hint": "Think about what allows safe transitions between user mode and kernel mode."
    },
    {
      "id": "linux-core-concepts-quiz-02",
      "type": "multiple-select",
      "question": "Which of the following are valid system calls in Linux?",
      "options": [
        "`fork()`",
        "`printf()`",
        "`mmap()`",
        "`socket()`",
        "`malloc()`"
      ],
      "answers": [0, 2, 3],
      "explanation": "`fork()`, `mmap()`, and `socket()` are system calls that interact with the kernel. `printf()` and `malloc()` are library functions from glibc that may internally use system calls like `write()` and `brk()`.",
      "hint": "System calls directly request kernel services. Library functions are wrappers that may call system calls internally."
    },
    {
      "id": "linux-core-concepts-quiz-03",
      "type": "true-false",
      "question": "User space applications have direct hardware access in Linux.",
      "answer": false,
      "explanation": "User space applications have NO direct hardware access. They must use system calls to request kernel services, which provides stability and security by preventing user programs from directly accessing hardware.",
      "hint": "Consider the security and stability benefits of the Linux architecture."
    },
    {
      "id": "linux-core-concepts-quiz-04",
      "type": "flashcard",
      "question": "What does the \"Everything is a File\" philosophy mean in Linux?",
      "answer": "**Linux treats almost everything as a file:**\n\n- Regular files (documents, programs)\n- Directories (special files containing other files)\n- Devices (hardware accessed through files)\n- Pipes (inter-process communication)\n- Sockets (network communication)\n\nThis unified interface simplifies system operations—the same operations (`open`, `read`, `write`, `close`) work on different types of resources."
    },
    {
      "id": "linux-core-concepts-quiz-05",
      "type": "mcq",
      "question": "Which directory contains virtual filesystems that are dynamically generated by the kernel and don't exist on disk?",
      "options": [
        "`/var` and `/tmp`",
        "`/proc` and `/sys`",
        "`/dev` and `/mnt`",
        "`/bin` and `/sbin`"
      ],
      "answer": 1,
      "explanation": "`/proc` and `/sys` are virtual filesystems dynamically generated by the kernel. `/proc` provides process and kernel information, while `/sys` provides device and driver information.",
      "hint": "Think about directories that provide runtime system information."
    },
    {
      "id": "linux-core-concepts-quiz-06",
      "type": "multiple-select",
      "question": "Which directories typically contain executable binaries in Linux?",
      "options": [
        "`/bin`",
        "`/etc`",
        "`/sbin`",
        "`/var`",
        "`/usr/bin`"
      ],
      "answers": [0, 2, 4],
      "explanation": "`/bin` contains essential user commands, `/sbin` contains system administration binaries, and `/usr/bin` contains user applications. `/etc` contains configuration files, and `/var` contains variable data.",
      "hint": "Look for directories with 'bin' in their names or purpose."
    },
    {
      "id": "linux-core-concepts-quiz-07",
      "type": "fill-blank",
      "question": "What command is used to view the contents of `/proc/cpuinfo` to see CPU details?",
      "answer": "cat",
      "caseSensitive": false,
      "explanation": "The `cat` command reads and displays file contents. Since `/proc/cpuinfo` is a virtual file, `cat /proc/cpuinfo` displays CPU information.",
      "hint": "It's a common command for reading file contents, often associated with felines."
    },
    {
      "id": "linux-core-concepts-quiz-08",
      "type": "true-false",
      "question": "Hard links can cross filesystem boundaries, while symbolic links cannot.",
      "answer": false,
      "explanation": "This is backwards. Hard links CANNOT cross filesystem boundaries (they must point to the same inode on the same filesystem), while symbolic links CAN cross filesystem boundaries (they're just special files containing a path).",
      "hint": "Consider which type of link points to an inode vs. a path."
    },
    {
      "id": "linux-core-concepts-quiz-09",
      "type": "drag-drop",
      "question": "Arrange the file type symbols in order from most common to least common in a typical Linux system:",
      "instruction": "Drag to arrange from most to least common",
      "items": [
        "- (regular file)",
        "d (directory)",
        "l (symbolic link)",
        "c (character device)",
        "b (block device)",
        "s (socket)",
        "p (named pipe)"
      ],
      "correctOrder": [0, 1, 2, 3, 4, 5, 6],
      "explanation": "Regular files are most common, followed by directories and symbolic links. Device files, sockets, and pipes are less common and typically found in specific locations like `/dev`."
    },
    {
      "id": "linux-core-concepts-quiz-10",
      "type": "mcq",
      "question": "What does the permission string `-rwsr-xr-x` indicate?",
      "options": [
        "A regular file with SGID set",
        "A regular file with SUID set",
        "A directory with sticky bit set",
        "A symbolic link with execute permissions"
      ],
      "answer": 1,
      "explanation": "The 's' in the owner execute position indicates SUID (Set User ID) is set. This means the file executes with the owner's privileges, not the caller's. An example is `/usr/bin/passwd`.",
      "hint": "Look at the position of the 's' character—is it in owner or group permissions?"
    },
    {
      "id": "linux-core-concepts-quiz-11",
      "type": "code-completion",
      "question": "Complete the command to give a file read and write permissions for owner, read-only for group, and no permissions for others:",
      "instruction": "Fill in the numeric permission value",
      "codeTemplate": "chmod ___ document.txt",
      "answer": "640",
      "caseSensitive": false,
      "acceptedAnswers": ["640"],
      "explanation": "640 = rw-r----- (owner: 6=4+2=rw-, group: 4=r--, others: 0=---). Owner can read(4) and write(2), group can read(4), others have no permissions(0).",
      "hint": "Read=4, Write=2, Execute=1. Add them up for each class: owner, group, others."
    },
    {
      "id": "linux-core-concepts-quiz-12",
      "type": "multiple-select",
      "question": "Which of the following are true about the sticky bit permission?",
      "options": [
        "It's represented by 't' in the others execute position",
        "It's typically used on directories like `/tmp`",
        "It allows only the file owner to delete their own files",
        "Its numeric value is 4000",
        "It prevents users from deleting others' files in shared directories"
      ],
      "answers": [0, 1, 2, 4],
      "explanation": "The sticky bit is shown as 't', typically used on `/tmp`, and ensures only file owners can delete their own files in shared directories. Its numeric value is 1000, not 4000 (which is SUID).",
      "hint": "The sticky bit is about file deletion control in shared directories."
    },
    {
      "id": "linux-core-concepts-quiz-13",
      "type": "drag-drop",
      "question": "Arrange the permission evaluation steps in the correct order:",
      "instruction": "Drag to arrange the permission check sequence",
      "items": [
        "Check if user is the file owner",
        "Apply owner permissions if owner",
        "Check if user is in file's group",
        "Apply group permissions if in group",
        "Apply others permissions"
      ],
      "correctOrder": [0, 1, 2, 3, 4],
      "explanation": "Linux checks permissions in order: owner → group → others, and STOPS at the first match. If you're the owner, only owner permissions apply, even if you're also in the group."
    },
    {
      "id": "linux-core-concepts-quiz-14",
      "type": "flashcard",
      "question": "What is the difference between `sudo -i` and `sudo -s`?",
      "answer": "**`sudo -i`**: Gives you a full login environment (like actually logging in as root)\n- Changes to root's home directory\n- Loads root's environment variables\n- Sources root's shell configuration files\n\n**`sudo -s`**: Just elevates your privileges\n- Keeps your current working directory\n- Keeps your current environment\n- Non-login shell"
    },
    {
      "id": "linux-core-concepts-quiz-15",
      "type": "mcq",
      "question": "What is the key difference between a program and a process?",
      "options": [
        "A program is stored in memory, a process is on disk",
        "A program is passive code on disk, a process is an active instance in execution",
        "A program has a PID, a process does not",
        "There is no difference, they are the same thing"
      ],
      "answer": 1,
      "explanation": "A program is an executable file on disk (passive, static), while a process is a program in execution with allocated resources like memory, CPU time, and a PID (active, dynamic).",
      "hint": "Think about the difference between a recipe (static) and actually cooking (active)."
    },
    {
      "id": "linux-core-concepts-quiz-16",
      "type": "code-output",
      "question": "What state code will you see in `ps aux` output for a process that has finished executing but is waiting to be cleaned up by its parent?",
      "code": "ps aux | grep defunct",
      "language": "bash",
      "options": [
        "R (Running)",
        "S (Sleeping)",
        "D (Uninterruptible sleep)",
        "Z (Zombie)"
      ],
      "answer": 3,
      "explanation": "A zombie process (Z state) has terminated but hasn't been reaped by its parent via `wait()`. It's waiting to be cleaned up and only occupies a process table entry.",
      "hint": "Think about what happens after a process dies but before cleanup."
    },
    {
      "id": "linux-core-concepts-quiz-17",
      "type": "multiple-select",
      "question": "Which signals CANNOT be caught or ignored by a process?",
      "options": [
        "SIGTERM (15)",
        "SIGKILL (9)",
        "SIGINT (2)",
        "SIGSTOP (19)",
        "SIGHUP (1)"
      ],
      "answers": [1, 3],
      "explanation": "SIGKILL (9) and SIGSTOP (19) cannot be caught, blocked, or ignored. This ensures the kernel can always terminate or stop a process. All other signals can be handled by the process.",
      "hint": "The kernel needs guaranteed ways to control processes."
    },
    {
      "id": "linux-core-concepts-quiz-18",
      "type": "fill-blank",
      "question": "What command is used to change the priority (nice value) of an already running process?",
      "answer": "renice",
      "caseSensitive": false,
      "explanation": "The `renice` command changes the priority of running processes. For example: `renice -n 5 -p 1234` sets the nice value to 5 for PID 1234. `nice` is used when starting a new process.",
      "hint": "It's similar to 'nice' but for processes that are already running."
    },
    {
      "id": "linux-core-concepts-quiz-19",
      "type": "true-false",
      "question": "A lower (more negative) nice value means higher priority in Linux process scheduling.",
      "answer": true,
      "explanation": "Nice values range from -20 (highest priority) to 19 (lowest priority). A lower/negative nice value gives the process more CPU time. Only root can set negative nice values.",
      "hint": "Think counterintuitively—being 'nicer' means lower priority."
    },
    {
      "id": "linux-core-concepts-quiz-20",
      "type": "mcq",
      "question": "What is systemd's PID (Process ID)?",
      "options": [
        "PID 0 (kernel)",
        "PID 1 (init system)",
        "PID 2 (kthreadd)",
        "It varies based on boot order"
      ],
      "answer": 1,
      "explanation": "systemd is the init system with PID 1. It's the first process started by the kernel and is the parent of all other processes. It manages system services and handles system state.",
      "hint": "The init system is always the first process started."
    },
    {
      "id": "linux-core-concepts-quiz-21",
      "type": "code-completion",
      "question": "Complete the command to enable a service to start at boot AND start it immediately:",
      "instruction": "Fill in the missing systemctl option",
      "codeTemplate": "sudo systemctl enable _____ nginx.service",
      "answer": "--now",
      "caseSensitive": false,
      "acceptedAnswers": ["--now"],
      "explanation": "The `--now` flag combines enable (start at boot) with start (start immediately). Without it, you'd need two commands: `systemctl enable` and `systemctl start`.",
      "hint": "It's a flag that means 'do it right now too'."
    },
    {
      "id": "linux-core-concepts-quiz-22",
      "type": "multiple-select",
      "question": "Which are valid systemd service types?",
      "options": [
        "simple",
        "forking",
        "oneshot",
        "daemon",
        "notify",
        "idle"
      ],
      "answers": [0, 1, 2, 4, 5],
      "explanation": "Valid service types are: simple (default), forking (traditional daemons), oneshot (runs once), notify (sends notification when ready), and idle (waits for other jobs). 'daemon' is not a systemd type.",
      "hint": "Most describe how the service process behaves or when it runs."
    },
    {
      "id": "linux-core-concepts-quiz-23",
      "type": "flashcard",
      "question": "What is a systemd target and how does it relate to SysV runlevels?",
      "answer": "**Systemd Targets** are units that group other units and define system states.\n\nThey replace SysV runlevels:\n- `poweroff.target` → runlevel 0 (shutdown)\n- `rescue.target` → runlevel 1 (single-user)\n- `multi-user.target` → runlevels 2,3,4 (multi-user, no GUI)\n- `graphical.target` → runlevel 5 (multi-user with GUI)\n- `reboot.target` → runlevel 6 (reboot)\n\nTargets are more flexible than runlevels and can have dependencies."
    },
    {
      "id": "linux-core-concepts-quiz-24",
      "type": "fill-blank",
      "question": "What systemd command is used to view logs for a specific service?",
      "answer": "journalctl",
      "caseSensitive": false,
      "explanation": "`journalctl` is systemd's integrated logging system. Use `journalctl -u service-name` to view logs for a specific service. For example: `journalctl -u nginx.service`.",
      "hint": "It's systemd's journal/logging command."
    },
    {
      "id": "linux-core-concepts-quiz-25",
      "type": "true-false",
      "question": "After editing a systemd unit file, you must run `systemctl daemon-reload` before restarting the service.",
      "answer": true,
      "explanation": "After editing unit files, `systemctl daemon-reload` is required to reload systemd's configuration. This tells systemd to re-read all unit files. Then you can restart the service with the new configuration.",
      "hint": "systemd needs to know about changes to its configuration files."
    },
    {
      "id": "linux-core-concepts-quiz-26",
      "type": "mcq",
      "question": "In Debian/Ubuntu systems, what is the relationship between dpkg and apt?",
      "options": [
        "dpkg is high-level and apt is low-level",
        "apt is high-level and dpkg is low-level",
        "They are completely independent tools",
        "apt has replaced dpkg entirely"
      ],
      "answer": 1,
      "explanation": "apt is the high-level tool that handles dependencies and repositories, while dpkg is the low-level tool that installs individual .deb packages. apt uses dpkg internally but adds dependency resolution and repository management.",
      "hint": "Think about which tool is easier to use and does more automatically."
    },
    {
      "id": "linux-core-concepts-quiz-27",
      "type": "multiple-select",
      "question": "Which apt commands modify the system's installed packages?",
      "options": [
        "`apt search`",
        "`apt install`",
        "`apt update`",
        "`apt remove`",
        "`apt upgrade`",
        "`apt show`"
      ],
      "answers": [1, 3, 4],
      "explanation": "`apt install`, `apt remove`, and `apt upgrade` modify installed packages. `apt update` only refreshes the package index, `apt search` and `apt show` are informational commands that don't modify the system.",
      "hint": "Which commands actually install, remove, or upgrade software?"
    },
    {
      "id": "linux-core-concepts-quiz-28",
      "type": "true-false",
      "question": "Running `apt update` will upgrade all packages on your system to their latest versions.",
      "answer": false,
      "explanation": "`apt update` only refreshes the package index from repositories—it doesn't upgrade anything. To actually upgrade packages, you need to run `apt upgrade` or `apt full-upgrade`.",
      "hint": "Consider the difference between updating the package list vs. updating the packages themselves."
    },
    {
      "id": "linux-core-concepts-quiz-29",
      "type": "drag-drop",
      "question": "Arrange the package installation flow in the correct order:",
      "instruction": "Drag to arrange the installation sequence",
      "items": [
        "User runs install command",
        "Check local package cache",
        "Resolve dependencies",
        "Download packages from repositories",
        "Verify package signatures",
        "Install dependencies in order",
        "Install main package",
        "Run post-install scripts"
      ],
      "correctOrder": [0, 1, 2, 3, 4, 5, 6, 7],
      "explanation": "Package managers follow this sequence to ensure all dependencies are met, packages are authentic, and everything is installed in the correct order before running any configuration scripts."
    },
    {
      "id": "linux-core-concepts-quiz-30",
      "type": "mcq",
      "question": "In the network stack, which layer is responsible for routing and IP addressing?",
      "options": [
        "Application Layer",
        "Transport Layer",
        "Network Layer",
        "Link Layer"
      ],
      "answer": 2,
      "explanation": "The Network Layer handles IP (Internet Protocol) for routing and addressing, and ICMP for error messages and diagnostics like ping. The Transport Layer has TCP/UDP, Link Layer has Ethernet/WiFi.",
      "hint": "Think about where IP addresses are used."
    },
    {
      "id": "linux-core-concepts-quiz-31",
      "type": "code-completion",
      "question": "Complete the modern command to show all network interfaces and their IP addresses:",
      "instruction": "Fill in the command name",
      "codeTemplate": "___ addr show",
      "answer": "ip",
      "caseSensitive": false,
      "acceptedAnswers": ["ip"],
      "explanation": "The `ip` command from iproute2 is the modern replacement for `ifconfig`. `ip addr show` displays all network interfaces and their IP addresses. It's faster and more feature-rich than the legacy `ifconfig`.",
      "hint": "It's a two-letter command that's the modern replacement for ifconfig."
    },
    {
      "id": "linux-core-concepts-quiz-32",
      "type": "multiple-select",
      "question": "What do the flags in `ss -tulnp` represent?",
      "options": [
        "t = TCP connections",
        "u = UDP connections",
        "l = Listening sockets",
        "n = Numeric (don't resolve names)",
        "p = Show process"
      ],
      "answers": [0, 1, 2, 3, 4],
      "explanation": "All options are correct. `ss -tulnp` shows TCP and UDP listening sockets with numeric addresses and process information. It's the modern replacement for `netstat` and is faster.",
      "hint": "Each flag represents a filter or display option."
    },
    {
      "id": "linux-core-concepts-quiz-33",
      "type": "fill-blank",
      "question": "What file contains the system's DNS server configuration?",
      "answer": "/etc/resolv.conf",
      "caseSensitive": false,
      "explanation": "`/etc/resolv.conf` contains DNS server addresses (nameserver entries) and search domains. Each nameserver line specifies a DNS server to query for domain name resolution.",
      "hint": "It's in /etc and relates to 'resolving' domain names."
    },
    {
      "id": "linux-core-concepts-quiz-34",
      "type": "true-false",
      "question": "NetworkManager is typically better suited for servers with static configurations, while systemd-networkd is better for desktops and laptops.",
      "answer": false,
      "explanation": "This is backwards. NetworkManager is best for dynamic networks (desktops/laptops with WiFi, VPNs, frequent changes), while systemd-networkd is better for servers with static configurations and minimal overhead.",
      "hint": "Consider which tool is designed for frequently changing network environments."
    },
    {
      "id": "linux-core-concepts-quiz-35",
      "type": "flashcard",
      "question": "What are the three main process states visible in ps/top and what do they mean?",
      "answer": "**R - Running or Runnable**: Process is executing on CPU or waiting in run queue for CPU time\n\n**S - Interruptible Sleep**: Process is waiting for an event (like I/O completion) and can be interrupted by signals\n\n**D - Uninterruptible Sleep**: Process is waiting for I/O and cannot be interrupted (usually brief, indicates disk/network I/O)\n\n**Bonus states:**\n- **T - Stopped**: Paused by job control (Ctrl+Z) or debugger\n- **Z - Zombie**: Terminated but waiting for parent to collect exit status"
    }
  ]
}
{{< /quiz >}}

