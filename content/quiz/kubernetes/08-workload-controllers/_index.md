---
title: Workload Controllers Quiz
linkTitle: Workload Controllers
type: docs
weight: 08
prev: /quiz/kubernetes/07-pod-lifecycle
next: /quiz/kubernetes/09-services
---

{{< quiz id="kubernetes-workload-controllers-quiz" >}}
{
  "questions": [
    {
      "id": "kubernetes-workload-controllers-quiz-01",
      "type": "mcq",
      "question": "Why should you NOT create ReplicaSets directly in production?",
      "options": [
        "ReplicaSets are deprecated and will be removed in future Kubernetes versions",
        "ReplicaSets don't support rolling updates or rollbacks; Deployments provide these features",
        "ReplicaSets consume more resources than Deployments",
        "ReplicaSets can only manage one pod at a time"
      ],
      "answer": 1,
      "explanation": "ReplicaSets DO provide self-healing and scaling by maintaining the desired replica count. However, they don't support rolling updates (gradually replacing pods with new versions) or rollbacks (reverting to previous versions). Deployments layer these critical update strategies on top of ReplicaSets, making them essential for production workloads where you need to update applications safely without downtime.",
      "hint": "Think about what features you get with higher-level abstractions."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-02",
      "type": "flashcard",
      "question": "Explain the three nested `spec` levels in a Deployment manifest and what each controls.",
      "answer": "**Three nested spec levels:**\n\n1. **Deployment spec** (top-level): Controls the Deployment lifecycle\n   - `replicas`: How many pods to maintain\n   - `strategy`: Update strategy (RollingUpdate, Recreate)\n   - `selector`: Which pods this Deployment manages\n\n2. **Pod template spec** (under `template.spec`): Defines pod configuration\n   - `volumes`: Storage volumes\n   - `restartPolicy`: Container restart behavior\n   - `securityContext`: Pod-level security settings\n\n3. **Container spec** (under `template.spec.containers`): Individual container settings\n   - `image`: Container image to run\n   - `ports`: Exposed ports\n   - `resources`: CPU/memory requests and limits\n   - `probes`: Liveness and readiness probes"
    },
    {
      "id": "kubernetes-workload-controllers-quiz-03",
      "type": "multiple-select",
      "question": "During a rolling update with `maxSurge: 1` and `maxUnavailable: 0`, which statements are TRUE?",
      "options": [
        "At most 1 extra pod above the replica count can exist temporarily",
        "The minimum number of available pods never drops below the replica count",
        "Old pods are terminated before new pods are created",
        "New pods must pass readiness probes before old pods are terminated",
        "Both old and new ReplicaSets can have active pods simultaneously"
      ],
      "answers": [0, 1, 3, 4],
      "explanation": "`maxSurge: 1` allows 1 extra pod temporarily. `maxUnavailable: 0` ensures no pods go unavailable, maintaining full availability. New pods must be ready before old ones are removed. Both ReplicaSets exist during the update. Option 3 is false - new pods are created first.",
      "hint": "Think about zero-downtime deployments and readiness requirements."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-04",
      "type": "code-output",
      "question": "What happens when you apply this configuration to a Deployment currently running 3 replicas of `nginx:1.21`?",
      "code": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-app\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 0\n      maxUnavailable: 1\n  template:\n    spec:\n      containers:\n      - name: web\n        image: nginx:1.22",
      "language": "yaml",
      "options": [
        "All 3 pods are terminated simultaneously and then recreated with nginx:1.22",
        "1 old pod is terminated, then 1 new pod created; process repeats until all updated",
        "1 new pod is created, then 1 old pod is terminated; process repeats",
        "The update fails because maxSurge and maxUnavailable cannot both be set"
      ],
      "answer": 1,
      "explanation": "With `maxSurge: 0` (no extra pods) and `maxUnavailable: 1` (one can be down), Kubernetes terminates 1 old pod first, then creates 1 new pod with the updated image. This continues sequentially, causing brief moments with only 2 pods available.",
      "hint": "When maxSurge=0, no extra pods can be created above the replica count."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-05",
      "type": "true-false",
      "question": "The `pod-template-hash` label is manually added by users to track different versions of pods.",
      "answer": false,
      "explanation": "False! The `pod-template-hash` label is automatically generated by the Deployment controller. It's a hash of the pod template specification and is used to uniquely identify ReplicaSets and prevent selector conflicts during rolling updates.",
      "hint": "Think about who manages internal Kubernetes labels."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-06",
      "type": "fill-blank",
      "question": "The `revisionHistoryLimit` parameter controls how many old _____ are retained for rollback capability.",
      "answer": "ReplicaSets",
      "caseSensitive": false,
      "acceptedAnswers": ["ReplicaSets", "replicasets", "replica sets", "ReplicaSet"],
      "explanation": "The `revisionHistoryLimit` (default: 10) specifies how many old ReplicaSets to keep. These scaled-to-zero ReplicaSets allow you to rollback to previous versions. Setting it to 0 would prevent rollbacks.",
      "hint": "What does a Deployment create to manage pods?"
    },
    {
      "id": "kubernetes-workload-controllers-quiz-07",
      "type": "mcq",
      "question": "You set `minReadySeconds: 30` on a Deployment. A new pod passes its readiness probe at t=10s but crashes at t=25s. What happens?",
      "options": [
        "The pod is considered available and the rolling update continues",
        "The rolling update pauses because the pod didn't stay ready for 30 seconds",
        "The pod is immediately restarted and the rolling update continues",
        "The entire deployment is rolled back automatically"
      ],
      "answer": 1,
      "explanation": "`minReadySeconds` requires a pod to stay ready for the specified duration before being considered available. If the pod crashes during this period, it's NOT considered available, and the rolling update pauses to prevent rolling out a bad version.",
      "hint": "This parameter exists to prevent premature rollouts of unstable versions."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-08",
      "type": "code-completion",
      "question": "Complete the Deployment strategy to achieve a blue-green deployment pattern (all new pods created before any old ones are terminated):",
      "instruction": "Fill in the maxSurge value for 3 replicas",
      "codeTemplate": "strategy:\n  type: RollingUpdate\n  rollingUpdate:\n    maxSurge: _____\n    maxUnavailable: 0",
      "answer": "3",
      "caseSensitive": false,
      "acceptedAnswers": ["3", "100%"],
      "explanation": "For blue-green deployment with 3 replicas, set `maxSurge: 3` (or `100%`) to allow all 3 new pods to be created alongside the 3 old pods. Combined with `maxUnavailable: 0`, this ensures all old pods remain until all new pods are ready.",
      "hint": "Blue-green means running both versions fully at the same time."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-09",
      "type": "drag-drop",
      "question": "Arrange the rolling update steps in the correct order:",
      "instruction": "Drag to sequence from first to last",
      "items": [
        "Create new ReplicaSet with updated pod template",
        "Scale up new ReplicaSet (controlled by maxSurge)",
        "Wait for new pods to pass readiness probe",
        "Scale down old ReplicaSet (controlled by maxUnavailable)",
        "Old ReplicaSet reaches zero pods",
        "Rolling update complete"
      ],
      "correctOrder": [0, 1, 2, 3, 4, 5],
      "explanation": "Rolling updates follow this precise sequence: create new ReplicaSet → gradually scale up new pods → wait for readiness → gradually scale down old pods → complete when old ReplicaSet is at zero."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-10",
      "type": "mcq",
      "question": "What is the primary difference between a Deployment and a StatefulSet?",
      "options": [
        "Deployments can scale but StatefulSets cannot",
        "StatefulSets provide stable pod identities and persistent storage per pod; Deployments use random pod names and ephemeral storage",
        "StatefulSets are only for databases; Deployments are for web applications",
        "Deployments support rolling updates but StatefulSets do not"
      ],
      "answer": 1,
      "explanation": "StatefulSets provide stable, ordered pod identities (app-0, app-1, app-2) and persistent storage per pod, making them suitable for stateful applications. Deployments use random pod names and are designed for stateless applications where pods are interchangeable.",
      "hint": "Think about what 'stateful' means - stable identity and persistent data."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-11",
      "type": "multiple-select",
      "question": "Which characteristics are true for StatefulSets?",
      "options": [
        "Pod names follow a pattern: <statefulset-name>-<ordinal>",
        "Pods are created in parallel for faster deployment",
        "Each pod can have its own PersistentVolumeClaim",
        "Scaling down deletes pods in reverse order (highest ordinal first)",
        "Pods are interchangeable and can be replaced randomly"
      ],
      "answers": [0, 2, 3],
      "explanation": "StatefulSets use ordered naming (app-0, app-1), sequential deployment/scaling, persistent storage per pod via volumeClaimTemplates, and reverse-order deletion. Pods are NOT interchangeable - each has a stable identity.",
      "hint": "StatefulSets are all about order and stability."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-12",
      "type": "code-output",
      "question": "A StatefulSet named `database` has 3 replicas. You scale it to 5 replicas. What happens?",
      "code": "kubectl scale statefulset database --replicas=5",
      "language": "bash",
      "options": [
        "database-3 and database-4 are created in parallel immediately",
        "database-3 is created and must be Ready before database-4 starts",
        "All 5 pods are recreated from scratch in order",
        "The operation fails because StatefulSets cannot be scaled"
      ],
      "answer": 1,
      "explanation": "StatefulSets scale sequentially. When scaling from 3 to 5, `database-3` is created first. Only after it becomes Ready will `database-4` be created. This ordered scaling ensures each pod is stable before proceeding.",
      "hint": "StatefulSets maintain strict ordering during scaling."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-13",
      "type": "fill-blank",
      "question": "A StatefulSet requires a _____ Service to provide stable DNS entries for each pod.",
      "answer": "Headless",
      "caseSensitive": false,
      "acceptedAnswers": ["Headless", "headless", "Headless Service"],
      "explanation": "A Headless Service (with `clusterIP: None`) is required for StatefulSets. It creates DNS entries like `<pod-name>.<service-name>.<namespace>.svc.cluster.local`, providing stable network identities for each pod.",
      "hint": "This type of service has clusterIP set to None."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-14",
      "type": "flashcard",
      "question": "Explain what volumeClaimTemplates in a StatefulSet do and how they differ from regular volume claims.",
      "answer": "**volumeClaimTemplates:**\n\n- Creates a **unique PersistentVolumeClaim for each pod** in the StatefulSet\n- Each PVC is bound to a specific pod ordinal (e.g., data-mysql-0, data-mysql-1)\n- **PVCs persist even if pods are deleted** - when a pod is recreated, it reattaches to the same PVC\n- Scaling up creates new PVCs; scaling down does NOT delete PVCs (manual cleanup required)\n\n**vs. Regular volumes:**\n- Regular volumes are shared by all pods or ephemeral\n- volumeClaimTemplates create **per-pod persistent storage**\n- Essential for stateful applications needing individual, persistent data storage"
    },
    {
      "id": "kubernetes-workload-controllers-quiz-15",
      "type": "mcq",
      "question": "A DaemonSet is deployed to a cluster with 5 nodes. How many pods will be created?",
      "options": [
        "1 pod total (DaemonSets only run a single pod)",
        "5 pods (one per node)",
        "It depends on the replicas field in the DaemonSet spec",
        "0 pods (DaemonSets need explicit nodeSelector to function)"
      ],
      "answer": 1,
      "explanation": "DaemonSets automatically create one pod per node in the cluster. With 5 nodes, it creates 5 pods. There is no `replicas` field - the number of nodes determines the pod count. If a node is added, a new pod is automatically created on it.",
      "hint": "DaemonSets ensure cluster-wide coverage."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-16",
      "type": "true-false",
      "question": "DaemonSets respect node taints and will not schedule pods on tainted nodes unless the pod has matching tolerations.",
      "answer": true,
      "explanation": "True! DaemonSets respect the same scheduling constraints as other workloads, including taints and tolerations. To run on tainted nodes (like master nodes), the DaemonSet pod template must include appropriate tolerations.",
      "hint": "Scheduling rules apply consistently across all workload types."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-17",
      "type": "code-output",
      "question": "What happens when you apply this DaemonSet to a cluster with 3 worker nodes and 2 nodes labeled `accelerator=nvidia`?",
      "code": "apiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: gpu-plugin\nspec:\n  selector:\n    matchLabels:\n      app: gpu\n  template:\n    metadata:\n      labels:\n        app: gpu\n    spec:\n      nodeSelector:\n        accelerator: nvidia\n      containers:\n      - name: plugin\n        image: gpu-plugin:1.0",
      "language": "yaml",
      "options": [
        "5 pods are created (one per node)",
        "2 pods are created (only on nodes with accelerator=nvidia label)",
        "3 pods are created (one per worker node)",
        "0 pods are created (nodeSelector conflicts with DaemonSet behavior)"
      ],
      "answer": 1,
      "explanation": "The `nodeSelector` restricts the DaemonSet to only nodes with the `accelerator=nvidia` label. Even though there are 5 total nodes, only 2 match the selector, so only 2 pods are created.",
      "hint": "nodeSelector filters which nodes the DaemonSet runs on."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-18",
      "type": "mcq",
      "question": "What is the main difference between a Job and a Deployment?",
      "options": [
        "Jobs cannot run multiple pods, Deployments can",
        "Jobs run pods to completion and then stop; Deployments keep pods running continuously",
        "Jobs are scheduled by CronJobs; Deployments are not",
        "Jobs support rolling updates; Deployments do not"
      ],
      "answer": 1,
      "explanation": "Jobs are designed for finite tasks - they run pods to completion and track success/failure. Deployments keep pods running continuously and restart them if they exit. Jobs use `restartPolicy: Never` or `OnFailure`, while Deployments use `Always`.",
      "hint": "Think about the lifecycle: finite task vs. long-running service."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-19",
      "type": "multiple-select",
      "question": "Which fields control Job parallelism and completion behavior?",
      "options": [
        "`completions` - Total number of successful pod completions required",
        "`parallelism` - Maximum number of pods running simultaneously",
        "`replicas` - Number of pods to maintain",
        "`backoffLimit` - Number of retries on failure",
        "`ttlSecondsAfterFinished` - Time to keep completed job before deletion"
      ],
      "answers": [0, 1, 3, 4],
      "explanation": "Jobs use `completions` (total pods needed), `parallelism` (concurrent pods), `backoffLimit` (retry count), and `ttlSecondsAfterFinished` (cleanup time). There is no `replicas` field - that's for Deployments/ReplicaSets.",
      "hint": "Jobs have different terminology than continuous workloads."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-20",
      "type": "code-output",
      "question": "A Job is configured with `completions: 10` and `parallelism: 3`. How does it execute?",
      "code": "spec:\n  completions: 10\n  parallelism: 3\n  template:\n    spec:\n      containers:\n      - name: worker\n        image: processor:1.0\n      restartPolicy: OnFailure",
      "language": "yaml",
      "options": [
        "All 10 pods start simultaneously",
        "3 pods run at a time; after one completes, another starts until 10 total completions",
        "Only 3 pods run total, then the job completes",
        "The configuration is invalid (completions must equal parallelism)"
      ],
      "answer": 1,
      "explanation": "The Job runs 3 pods in parallel (wave 1). As each completes successfully, a new pod starts. This continues until 10 total successful completions are achieved. Think of it as processing a queue with 3 workers.",
      "hint": "Think of parallelism as worker count and completions as total work items."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-21",
      "type": "fill-blank",
      "question": "In a Job spec, what `restartPolicy` values are allowed?",
      "answer": "Never",
      "caseSensitive": false,
      "acceptedAnswers": ["Never", "OnFailure", "Never or OnFailure"],
      "explanation": "Jobs can only use `restartPolicy: Never` (don't restart, create new pod on failure) or `OnFailure` (restart container on failure). The `Always` policy is NOT allowed for Jobs because they are meant to run to completion, not continuously.",
      "hint": "Jobs are finite tasks, not long-running services."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-22",
      "type": "flashcard",
      "question": "Explain the three CronJob concurrencyPolicy options and when to use each.",
      "answer": "**CronJob concurrencyPolicy options:**\n\n1. **Allow** (default)\n   - Multiple job instances can run simultaneously\n   - Use when: Jobs are independent and can overlap safely\n   - Example: Hourly log analysis where overlapping is fine\n\n2. **Forbid**\n   - Skip the new job if the previous one hasn't finished\n   - Use when: Jobs must not overlap (e.g., exclusive resource access)\n   - Example: Database backup that locks tables\n\n3. **Replace**\n   - Cancel the running job and start the new one\n   - Use when: Only the latest execution matters\n   - Example: Generating a \"current status\" report where old jobs are obsolete"
    },
    {
      "id": "kubernetes-workload-controllers-quiz-23",
      "type": "code-completion",
      "question": "Complete the CronJob schedule to run every day at 2:30 AM:",
      "instruction": "Fill in the cron expression",
      "codeTemplate": "apiVersion: batch/v1\nkind: CronJob\nmetadata:\n  name: daily-backup\nspec:\n  schedule: \"_____\"\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          containers:\n          - name: backup\n            image: backup:1.0",
      "answer": "30 2 * * *",
      "caseSensitive": false,
      "acceptedAnswers": ["30 2 * * *"],
      "explanation": "Cron format: `minute hour day month day-of-week`. For 2:30 AM daily: `30` (minute) `2` (hour) `*` (any day) `*` (any month) `*` (any day of week) = `30 2 * * *`.",
      "hint": "Format: minute hour day month day-of-week"
    },
    {
      "id": "kubernetes-workload-controllers-quiz-24",
      "type": "drag-drop",
      "question": "Arrange these CronJob schedules from MOST frequent to LEAST frequent:",
      "instruction": "Order from most frequent (top) to least frequent (bottom)",
      "items": [
        "0 0 1 * *",
        "*/5 * * * *",
        "0 9 * * 1-5",
        "0 * * * *"
      ],
      "correctOrder": [1, 3, 2, 0],
      "explanation": "Frequency order: Every 5 minutes (288/day) → Every hour (24/day) → Weekdays at 9 AM (5/week) → First of month (12/year). Remember: smaller time units = higher frequency."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-25",
      "type": "true-false",
      "question": "When you delete a StatefulSet with default settings, all associated PersistentVolumeClaims are automatically deleted.",
      "answer": false,
      "explanation": "False! By default, PVCs created by a StatefulSet's volumeClaimTemplates are NOT automatically deleted when the StatefulSet is deleted. This prevents accidental data loss. You must manually delete PVCs if needed.",
      "hint": "Kubernetes errs on the side of data safety."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-26",
      "type": "mcq",
      "question": "You have a Deployment with 5 replicas and want to temporarily stop it without losing its configuration. What should you do?",
      "options": [
        "Delete the Deployment",
        "Scale it to 0 replicas",
        "Pause the rollout with `kubectl rollout pause`",
        "Set `suspend: true` in the spec"
      ],
      "answer": 1,
      "explanation": "Scaling to 0 replicas (`kubectl scale deploy <name> --replicas=0`) stops all pods while preserving the Deployment configuration. You can later scale back up. `rollout pause` stops updates but doesn't stop pods. `suspend` is for CronJobs, not Deployments.",
      "hint": "Think about how to maintain 0 pods while keeping the resource."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-27",
      "type": "multiple-select",
      "question": "Which workload controllers create pods that run continuously (not to completion)?",
      "options": [
        "Deployment",
        "Job",
        "StatefulSet",
        "CronJob",
        "DaemonSet"
      ],
      "answers": [0, 2, 4],
      "explanation": "Deployments, StatefulSets, and DaemonSets create long-running pods that restart if they exit (`restartPolicy: Always`). Jobs and CronJobs create pods that run to completion with `restartPolicy: Never` or `OnFailure`.",
      "hint": "Which controllers are for services vs. batch tasks?"
    },
    {
      "id": "kubernetes-workload-controllers-quiz-28",
      "type": "code-output",
      "question": "What is the result of this rollback command when the current revision is 5?",
      "code": "kubectl rollout undo deployment web-app --to-revision=3",
      "language": "bash",
      "options": [
        "The Deployment rolls back to revision 4 (previous revision)",
        "The Deployment rolls back to revision 3 (specific version)",
        "The Deployment rolls forward to revision 6",
        "The command fails (can only rollback to previous revision)"
      ],
      "answer": 1,
      "explanation": "The `--to-revision=3` flag explicitly rolls back to revision 3, regardless of the current revision. Without this flag, `kubectl rollout undo` would rollback to the immediate previous revision (4 in this case).",
      "hint": "The --to-revision flag allows targeting specific revisions."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-29",
      "type": "mcq",
      "question": "What happens to the old ReplicaSet after a successful rolling update?",
      "options": [
        "It is immediately deleted",
        "It is scaled to 0 replicas but retained for rollback capability",
        "It is converted into a backup Deployment",
        "It continues running with 1 replica for redundancy"
      ],
      "answer": 1,
      "explanation": "After a successful rolling update, the old ReplicaSet is scaled to 0 replicas but NOT deleted. It's retained (up to `revisionHistoryLimit` count) to enable rollbacks. This allows quick restoration to previous versions.",
      "hint": "Think about how rollbacks work without re-downloading images."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-30",
      "type": "fill-blank",
      "question": "The `progressDeadlineSeconds` parameter sets a timeout for deployment progress. The default value is _____ seconds.",
      "answer": "600",
      "caseSensitive": false,
      "acceptedAnswers": ["600"],
      "explanation": "The default `progressDeadlineSeconds` is 600 seconds (10 minutes). If a deployment doesn't make progress within this time (new pod ready, old pod terminated, or status change), it's marked as failed.",
      "hint": "It's 10 minutes expressed in seconds."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-31",
      "type": "true-false",
      "question": "A DaemonSet can be configured with rolling update strategy similar to Deployments.",
      "answer": true,
      "explanation": "True! DaemonSets support rolling updates controlled by `updateStrategy.type: RollingUpdate` and `updateStrategy.rollingUpdate.maxUnavailable`, which specifies how many nodes can update simultaneously. However, unlike Deployments, DaemonSets don't support canary deployments.",
      "hint": "Most Kubernetes resources support gradual updates."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-32",
      "type": "mcq",
      "question": "In the context of Deployments, what does the `selector` field do?",
      "options": [
        "It selects which nodes the pods should run on",
        "It selects which pods this Deployment manages based on their labels",
        "It selects which container image to use",
        "It selects the update strategy for rolling updates"
      ],
      "answer": 1,
      "explanation": "The `selector` field uses label matching to identify which pods the Deployment manages. It must match the labels in `template.metadata.labels`. This allows the Deployment controller to track and manage the correct pods.",
      "hint": "Selectors are about identifying resources, not placement."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-33",
      "type": "flashcard",
      "question": "Compare the use cases for Deployment vs. StatefulSet vs. DaemonSet. When would you use each?",
      "answer": "**Deployment:**\n- **Use for:** Stateless applications (web apps, APIs, microservices)\n- **Characteristics:** Pods are interchangeable, ephemeral storage, parallel deployment\n- **Example:** REST API server, web frontend, stateless processing service\n\n**StatefulSet:**\n- **Use for:** Stateful applications requiring stable identity and stable storage\n- **Characteristics:** Ordered pods, stable network IDs, stable per-pod storage (each pod always reattaches to its specific PVC)\n- **Example:** Databases (MySQL, PostgreSQL), message brokers (Kafka, RabbitMQ), distributed systems (Zookeeper, etcd)\n\n**DaemonSet:**\n- **Use for:** Cluster-wide services that must run on every node (or selected nodes)\n- **Characteristics:** One pod per node, automatic scaling with cluster\n- **Example:** Log collectors (Fluentd), monitoring agents (Prometheus Node Exporter), network plugins (Calico), storage daemons"
    },
    {
      "id": "kubernetes-workload-controllers-quiz-34",
      "type": "code-output",
      "question": "A Job has `backoffLimit: 3`. The pod fails 4 times. What happens?",
      "code": "spec:\n  backoffLimit: 3\n  template:\n    spec:\n      containers:\n      - name: worker\n        image: processor:1.0\n      restartPolicy: Never",
      "language": "yaml",
      "options": [
        "The Job keeps retrying indefinitely",
        "The Job is marked as failed after 3 retries (4 total attempts)",
        "The Job succeeds after 4 attempts",
        "The Job is immediately deleted"
      ],
      "answer": 1,
      "explanation": "`backoffLimit: 3` means the Job will retry up to 3 times after the initial failure. After 4 total attempts (1 initial + 3 retries) all fail, the Job is marked as Failed and stops creating new pods.",
      "hint": "backoffLimit is the number of RETRIES, not total attempts."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-35",
      "type": "multiple-select",
      "question": "Which parameters affect how long a Deployment takes to complete a rolling update?",
      "options": [
        "`minReadySeconds` - Adds wait time after each pod becomes ready",
        "`progressDeadlineSeconds` - Maximum time allowed for the entire update",
        "`maxSurge` - Controls how many pods can be created at once",
        "`maxUnavailable` - Controls how many pods can be terminated at once",
        "`revisionHistoryLimit` - Number of old ReplicaSets to keep"
      ],
      "answers": [0, 1, 2, 3],
      "explanation": "Update duration is affected by: `minReadySeconds` (stability wait), `progressDeadlineSeconds` (timeout), `maxSurge` (creation rate), and `maxUnavailable` (termination rate). `revisionHistoryLimit` only affects cleanup, not update speed.",
      "hint": "Think about factors that control the pace and timing of updates."
    },
    {
      "id": "kubernetes-workload-controllers-quiz-36",
      "type": "flashcard",
      "question": "Explain the functional purpose of each workload controller. What problem does each solve?",
      "answer": "**ReplicaSet:** Maintains pod count and self-healing (but no update strategy)\n\n**Deployment:** Provides rolling updates, rollbacks, and zero-downtime deployments\n\n**StatefulSet:** Manages stateful apps with stable identity, ordered deployment, and stable storage bindings\n\n**DaemonSet:** Ensures node-level coverage for cluster-wide services"
    }
  ]
}
{{< /quiz >}}
